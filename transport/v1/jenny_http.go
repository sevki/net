// Automatically generated by Jenny. DO NOT EDIT!

// Package v1 as generated by Jenny
// Please read about it https://localhost:8080/_spec
package v1

import (
	"context"
	"net/http"

	"github.com/Typeform/jenny/encoders"
	"github.com/Typeform/jenny/mime"
	"github.com/Typeform/jenny/options"
	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
)

// HTTP transport after this

// HTTP encoders
const contentType = "Content-Type"

func encodeWhoisResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {

	produces := []mime.Type{"application/json"}

	resp := response.(_whoisResponse)

	statusCode := 200

	w.WriteHeader(statusCode)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(contentType, string(mt))
	enc := newEnc(w)
	if err := enc.Encode(resp.Body); err != nil {
		return err
	}

	return nil
}

// HTTP decoders
func decodeWhoisRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _whoisRequest{}

	// Extract Name from path which is a string
	{
		val := mux.Vars(r)["name"]
		request.Name = val

		if err != nil {
			return nil, err
		}
	}

	return request, err
}

// NewNetHTTPServer returns a HTTPHandler that can be used with the go std http package
func NewNetHTTPServer(svc Net, opts ...options.Option) http.Handler {
	r := mux.NewRouter()
	svcOptions := options.New()
	for _, optf := range opts {
		optf(svcOptions)
	}

	{
		svcOptions.RegisterMiddleware("Whois",
			encoders.AcceptsMustMatch([]mime.Type{
				"application/json",
			}),
		)

		whoisEndpoint := makeWhoisEndpoint(svc, svcOptions)
		whoisHandler := httptransport.NewServer(
			whoisEndpoint,
			decodeWhoisRequest,
			encodeWhoisResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/whois/{name}", whoisHandler).Methods("GET")
	}

	return r
}
